---
title: Redux Islands - Store Global con Preservaci√≥n de SSR
author: Frontium Videos Team
category: coding
language: es
---

# REGLA: Redux Islands - Store Global con Preservaci√≥n de SSR

## Contexto
Esta regla define la implementaci√≥n de "Redux Islands" (Islas de Redux) para Next.js 15, una estrategia avanzada que permite compartir estado global entre componentes separados mientras preserva Server-Side Rendering (SSR) y optimiza la hidrataci√≥n.

## Concepto Clave: "Islas de Interactividad"
En lugar de convertir toda la aplicaci√≥n en Client Components, creamos "islas" de interactividad donde solo los componentes que necesitan Redux son Client Components, manteniendo el resto como Server Components.

## Arquitectura

### 1. Store Global con Aislamiento por Sesi√≥n
```tsx
// src/store/globalStore.ts
import { makeStore, AppStore, RootState } from './store'

// Tipo para entrada del store con timestamp de actividad
type StoreEntry = {
  store: AppStore
  lastActivity: number
}

// Map para almacenar stores por sesi√≥n con timestamps
const storeMap = new Map<string, StoreEntry>()

// Tipo para estado inicial parcial
type InitialState = Partial<RootState>

// Generar ID √∫nico por sesi√≥n
function getSessionId(): string {
  if (typeof window !== 'undefined') {
    if (!window.__REDUX_STORE_SESSION_ID__) {
      window.__REDUX_STORE_SESSION_ID__ = `session_${Date.now()}_${Math.random()}`
    }
    return window.__REDUX_STORE_SESSION_ID__
  }
  return `server_${Date.now()}_${Math.random()}`
}

export function getGlobalStore(): AppStore {
  const sessionId = getSessionId()
  const now = Date.now()
  
  // üßπ CR√çTICO: Limpiar stores inactivos para evitar memory leaks
  cleanupOldStores()
  
  if (!storeMap.has(sessionId)) {
    storeMap.set(sessionId, {
      store: makeStore(getInitialState()),
      lastActivity: now
    })
  } else {
    // Actualizar timestamp de √∫ltima actividad
    const entry = storeMap.get(sessionId)!
    entry.lastActivity = now
  }
  
  return storeMap.get(sessionId)!.store
}

// üßπ LIMPIEZA AUTOM√ÅTICA DE STORES INACTIVOS
export function cleanupOldStores(maxAge = 30 * 60 * 1000) { // 30 minutos
  const now = Date.now()
  let cleanedCount = 0
  
  for (const [sessionId, entry] of storeMap.entries()) {
    if (now - entry.lastActivity > maxAge) {
      storeMap.delete(sessionId)
      cleanedCount++
    }
  }
  
  if (process.env.NODE_ENV === 'development' && cleanedCount > 0) {
    console.log(`üßπ Redux Store Cleanup: Removed ${cleanedCount} inactive stores`)
  }
  
  return cleanedCount
}

// üìä Funci√≥n para monitoreo de stores
export function getStoreStats() {
  const now = Date.now()
  const stats = {
    totalStores: storeMap.size,
    activeStores: 0,
    inactiveStores: 0
  }
  
  for (const [, entry] of storeMap.entries()) {
    const age = now - entry.lastActivity
    if (age < 5 * 60 * 1000) { // Activo si se us√≥ en los √∫ltimos 5 minutos
      stats.activeStores++
    } else {
      stats.inactiveStores++
    }
  }
  
  return stats
}

// Funci√≥n para resetear el store de la sesi√≥n actual
export function resetGlobalStore() {
  const sessionId = getSessionId()
  storeMap.delete(sessionId)
}
```

### 2. Provider Global
```tsx
// src/components/GlobalReduxProvider.tsx
'use client'
import { ReactNode } from 'react'
import { Provider } from 'react-redux'
import { getGlobalStore } from '@/store/globalStore'

interface GlobalReduxProviderProps {
  children: ReactNode
}

export default function GlobalReduxProvider({ children }: GlobalReduxProviderProps) {
  const store = getGlobalStore()
  return <Provider store={store}>{children}</Provider>
}
```

### 3. Componente Isla
```tsx
// src/components/ReduxIsland.tsx
'use client'
import { ReactNode } from 'react'
import GlobalReduxProvider from './GlobalReduxProvider'

interface ReduxIslandProps {
  children: ReactNode
  className?: string
}

export default function ReduxIsland({ children, className = '' }: ReduxIslandProps) {
  return (
    <div className={className}>
      <GlobalReduxProvider>
        {children}
      </GlobalReduxProvider>
    </div>
  )
}
```

## Uso Correcto

### Estructura de P√°gina
```tsx
// src/app/(root)/page.tsx - Server Component
import ReduxIsland from '@/components/ReduxIsland'
import ComponenteConRedux1 from './ComponenteConRedux1'
import ComponenteConRedux2 from './ComponenteConRedux2'
import ServerComponent from './ServerComponent'

export default function HomePage() {
  return (
    <div>
      {/* Isla 1 de Redux */}
      <ReduxIsland>
        <ComponenteConRedux1 />
      </ReduxIsland>
      
      {/* Server Component - sin Redux */}
      <ServerComponent />
      
      {/* Isla 2 de Redux - COMPARTE EL MISMO STORE */}
      <ReduxIsland>
        <ComponenteConRedux2 />
      </ReduxIsland>
    </div>
  )
}
```

### Componentes que Comparten Estado
```tsx
// ComponenteConRedux1.tsx
'use client'
import { useSelector, useDispatch } from 'react-redux'

export default function ComponenteConRedux1() {
  const favorites = useSelector(state => state.favorites)
  const dispatch = useDispatch()
  
  return (
    <div>
      <h3>Favoritos: {favorites.length}</h3>
      <button onClick={() => dispatch(addToFavorites({ id: 1 }))}>
        Agregar
      </button>
    </div>
  )
}

// ComponenteConRedux2.tsx (en otra isla)
'use client'
import { useSelector } from 'react-redux'

export default function ComponenteConRedux2() {
  const favorites = useSelector(state => state.favorites) // ‚Üê Mismo estado!
  return <div>Total: {favorites.length}</div>
}
```

## Ventajas

### ‚úÖ SSR Preservado
- Server Components se renderizan en el servidor
- Solo las "islas" se hidratan en el cliente
- Mejor rendimiento inicial y SEO

### ‚úÖ Estado Compartido
- Todas las islas comparten el mismo store global
- Cambios en una isla se reflejan en todas las dem√°s
- Estado consistente en toda la aplicaci√≥n

### ‚úÖ Hidrataci√≥n Granular
- Cada isla se hidrata independientemente
- Mejor experiencia de usuario
- Menos JavaScript inicial

### ‚úÖ Flexibilidad
- M√∫ltiples islas por p√°gina
- Cada isla puede contener m√∫ltiples componentes
- F√°cil mantenimiento y debugging

## Estructura de Hidrataci√≥n
```
P√°gina (Server Component)
‚îú‚îÄ‚îÄ ReduxIsland 1 (Client Component) ‚Üê Hidrataci√≥n 1
‚îÇ   ‚îî‚îÄ‚îÄ ComponenteConRedux1
‚îú‚îÄ‚îÄ ServerComponent (Server Component) ‚Üê Sin hidrataci√≥n
‚îî‚îÄ‚îÄ ReduxIsland 2 (Client Component) ‚Üê Hidrataci√≥n 2
    ‚îî‚îÄ‚îÄ ComponenteConRedux2
```

## Casos de Uso Ideales

### ‚úÖ Usar Redux Islands cuando:
- Necesitas compartir estado entre componentes separados
- Quieres preservar SSR y optimizar rendimiento
- Tienes componentes interactivos espec√≠ficos en p√°ginas mayormente est√°ticas
- Necesitas hidrataci√≥n granular

### ‚ùå No usar cuando:
- Solo un componente necesita estado local (usar useState)
- Todos los componentes de la p√°gina necesitan Redux (usar StoreProvider global)
- El estado no necesita ser compartido (usar m√∫ltiples StoreProviders independientes)

## Principios de Implementaci√≥n

1. **Layout sin Provider**: Mantener el layout como Server Component puro
2. **Store Singleton**: Un solo store global compartido entre todas las islas
3. **Islas Espec√≠ficas**: Crear islas solo donde se necesite Redux
4. **Server Components por Defecto**: Usar Server Components para todo lo que no necesite interactividad
5. **Hidrataci√≥n Optimizada**: Cada isla se hidrata independientemente

## Diferencias con StoreProvider Tradicional

### StoreProvider Tradicional (useRef)
```tsx
export default function StoreProvider({ children }: StoreProviderProps) {
  const storeRef = useRef<AppStore | undefined>(undefined)
  if (!storeRef.current) {
    storeRef.current = makeStore()
  }
  return <Provider store={storeRef.current}>{children}</Provider>
}
```

### Store Singleton Global (variable global)
```tsx
let globalStore: AppStore | undefined

export function getGlobalStore(): AppStore {
  if (!globalStore) {
    globalStore = makeStore()
  }
  return globalStore
}
```

### ¬øPor qu√© no useRef en el Singleton Global?

1. **Scope diferente**: 
   - `useRef` vive dentro del componente React
   - Variable global vive en el m√≥dulo JavaScript

2. **Persistencia**:
   - `useRef` se reinicia cuando el componente se desmonta
   - Variable global persiste durante toda la sesi√≥n

3. **Acceso**:
   - `useRef` solo accesible dentro del componente
   - Variable global accesible desde cualquier lugar

## üö® CR√çTICO: Gesti√≥n de Memoria en Producci√≥n

### ¬øPor qu√© es Importante la Limpieza de Stores?

Con **1000 usuarios concurrentes**, tendr√°s **1000 stores en memoria**. Sin limpieza autom√°tica:
- **Memory leaks**: El servidor puede quedarse sin memoria
- **Performance degradado**: Garbage collection m√°s frecuente
- **Crashes**: En casos extremos, el proceso puede morir

### Implementaci√≥n Obligatoria

```tsx
// ‚úÖ CORRECTO - Con limpieza autom√°tica
export function getGlobalStore(): AppStore {
  cleanupOldStores() // ‚Üê CR√çTICO: Llamar en cada acceso
  // ... resto del c√≥digo
}

// ‚ùå PELIGROSO - Sin limpieza autom√°tica
let globalStore: AppStore | undefined
export function getGlobalStore(): AppStore {
  if (!globalStore) {
    globalStore = makeStore()
  }
  return globalStore // ‚Üê Un solo store para todos (inseguro)
}
```

### Configuraci√≥n Recomendada

- **Desarrollo**: `maxAge = 5 minutos` (para testing r√°pido)
- **Producci√≥n**: `maxAge = 30-60 minutos` (balance memoria/UX)
- **Alta concurrencia**: `maxAge = 15 minutos` + monitoreo activo

### Monitoreo en Producci√≥n

```tsx
// Agregar logging para producci√≥n
if (process.env.NODE_ENV === 'production') {
  setInterval(() => {
    const stats = getStoreStats()
    if (stats.totalStores > 500) { // Umbral de alerta
      console.warn('‚ö†Ô∏è High store count:', stats)
    }
  }, 10 * 60 * 1000) // Cada 10 minutos
}
```

## Checklist para la IA
- [ ] ¬øEl layout permanece como Server Component?
- [ ] ¬øSe usa un storeMap con aislamiento por sesi√≥n?
- [ ] ¬øSe implement√≥ cleanupOldStores() correctamente?
- [ ] ¬øSe llama a la limpieza en cada acceso al store?
- [ ] ¬øLas islas solo envuelven componentes que necesitan Redux?
- [ ] ¬øLos Server Components permanecen sin 'use client'?
- [ ] ¬øEl estado se comparte correctamente entre islas?
- [ ] ¬øSe preserva el SSR para componentes no interactivos?
- [ ] ¬øSe configur√≥ monitoreo para detectar memory leaks?

## Referencias
- [redux-nextjs15-StoreProvider.prompt.md]
- [nextjs15-coding.prompt.md]
- [redux-favorites.prompt.md] 